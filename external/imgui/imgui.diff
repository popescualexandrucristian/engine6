Only in imgui: .github
diff -r imgui/LICENSE.txt imgui-master/LICENSE.txt
22,23d21
< 
< Updated version by Popescu Alexandru-Cristian(popescualexandrucristian@gmail.com) so it uses VMA for memory allocations, work well with dynamic rendering and it uses shaders from the target program where it is deployed.
\ No newline at end of file
diff -r imgui/backends/imgui_impl_vulkan.cpp imgui-master/backends/imgui_impl_vulkan.cpp
82d81
< #include <vma/vk_mem_alloc.h>
93,96c92,93
<     VkBuffer            VertexBuffer;
<     VkBuffer            IndexBuffer;
<     VmaAllocation       VertexBufferAllocation;
<     VmaAllocation       IndexBufferAllocation;
---
>     VkDeviceMemory      VertexBufferMemory;
>     VkDeviceMemory      IndexBufferMemory;
98a96,97
>     VkBuffer            VertexBuffer;
>     VkBuffer            IndexBuffer;
126c125
<     VmaAllocation               FontAllocation;
---
>     VkDeviceMemory              FontMemory;
130a130
>     VkCommandBuffer             FontCommandBuffer;
143c143
< bool ImGui_ImplVulkan_CreateDeviceObjects(uint32_t* vert_data, size_t vert_size, uint32_t* frag_data, size_t frag_size);
---
> bool ImGui_ImplVulkan_CreateDeviceObjects();
381c381
< static void CreateOrResizeBuffer(VkBuffer& buffer, VmaAllocation& memory_allocation, VkDeviceSize& p_buffer_size, size_t new_size, VkBufferUsageFlagBits usage)
---
> static void CreateOrResizeBuffer(VkBuffer& buffer, VkDeviceMemory& buffer_memory, VkDeviceSize& p_buffer_size, size_t new_size, VkBufferUsageFlagBits usage)
387,388c387,390
<         vmaDestroyBuffer(v->GPUAllocator, buffer, memory_allocation);
<         
---
>         vkDestroyBuffer(v->Device, buffer, v->Allocator);
>     if (buffer_memory != VK_NULL_HANDLE)
>         vkFreeMemory(v->Device, buffer_memory, v->Allocator);
> 
395,398c397
< 
<     VmaAllocationCreateInfo vmaalloc_info = {};
<     vmaalloc_info.usage = VMA_MEMORY_USAGE_CPU_TO_GPU;
<     err = vmaCreateBuffer(v->GPUAllocator, &buffer_info, &vmaalloc_info, &buffer, &memory_allocation, nullptr);
---
>     err = vkCreateBuffer(v->Device, &buffer_info, v->Allocator, &buffer);
403a403,408
>     VkMemoryAllocateInfo alloc_info = {};
>     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
>     alloc_info.allocationSize = req.size;
>     alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);
>     err = vkAllocateMemory(v->Device, &alloc_info, v->Allocator, &buffer_memory);
>     check_vk_result(err);
404a410,411
>     err = vkBindBufferMemory(v->Device, buffer, buffer_memory, 0);
>     check_vk_result(err);
485c492
<             CreateOrResizeBuffer(rb->VertexBuffer, rb->VertexBufferAllocation, rb->VertexBufferSize, vertex_size, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);
---
>             CreateOrResizeBuffer(rb->VertexBuffer, rb->VertexBufferMemory, rb->VertexBufferSize, vertex_size, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);
487c494
<             CreateOrResizeBuffer(rb->IndexBuffer, rb->IndexBufferAllocation, rb->IndexBufferSize, index_size, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);
---
>             CreateOrResizeBuffer(rb->IndexBuffer, rb->IndexBufferMemory, rb->IndexBufferSize, index_size, VK_BUFFER_USAGE_INDEX_BUFFER_BIT);
492c499
<         VkResult err = vmaMapMemory(v->GPUAllocator,rb->VertexBufferAllocation, (void**)(&vtx_dst));
---
>         VkResult err = vkMapMemory(v->Device, rb->VertexBufferMemory, 0, rb->VertexBufferSize, 0, (void**)(&vtx_dst));
494c501
<         err = vmaMapMemory(v->GPUAllocator, rb->IndexBufferAllocation, (void**)(&idx_dst));
---
>         err = vkMapMemory(v->Device, rb->IndexBufferMemory, 0, rb->IndexBufferSize, 0, (void**)(&idx_dst));
504,506c511,521
< 
<         vmaUnmapMemory(v->GPUAllocator, rb->VertexBufferAllocation);
<         vmaUnmapMemory(v->GPUAllocator, rb->IndexBufferAllocation);
---
>         VkMappedMemoryRange range[2] = {};
>         range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
>         range[0].memory = rb->VertexBufferMemory;
>         range[0].size = VK_WHOLE_SIZE;
>         range[1].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
>         range[1].memory = rb->IndexBufferMemory;
>         range[1].size = VK_WHOLE_SIZE;
>         err = vkFlushMappedMemoryRanges(v->Device, 2, range);
>         check_vk_result(err);
>         vkUnmapMemory(v->Device, rb->VertexBufferMemory);
>         vkUnmapMemory(v->Device, rb->IndexBufferMemory);
594c609
<     if (bd->FontView || bd->FontImage || bd->FontAllocation || bd->FontDescriptorSet)
---
>     if (bd->FontView || bd->FontImage || bd->FontMemory || bd->FontDescriptorSet)
604a620
>         info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
608,609c624
< 
<     VkCommandBuffer fontCommandBuffer = VK_NULL_HANDLE;
---
>     if (bd->FontCommandBuffer == VK_NULL_HANDLE)
615c630
<         err = vkAllocateCommandBuffers(v->Device, &info, &fontCommandBuffer);
---
>         err = vkAllocateCommandBuffers(v->Device, &info, &bd->FontCommandBuffer);
626c641
<         err = vkBeginCommandBuffer(fontCommandBuffer, &begin_info);
---
>         err = vkBeginCommandBuffer(bd->FontCommandBuffer, &begin_info);
651,654c666,676
< 
<         VmaAllocationCreateInfo vmaalloc_info = {};
<         vmaalloc_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;
<         err = vmaCreateImage(v->GPUAllocator, &info, &vmaalloc_info, &bd->FontImage, &bd->FontAllocation, nullptr);
---
>         err = vkCreateImage(v->Device, &info, v->Allocator, &bd->FontImage);
>         check_vk_result(err);
>         VkMemoryRequirements req;
>         vkGetImageMemoryRequirements(v->Device, bd->FontImage, &req);
>         VkMemoryAllocateInfo alloc_info = {};
>         alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
>         alloc_info.allocationSize = req.size;
>         alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, req.memoryTypeBits);
>         err = vkAllocateMemory(v->Device, &alloc_info, v->Allocator, &bd->FontMemory);
>         check_vk_result(err);
>         err = vkBindImageMemory(v->Device, bd->FontImage, bd->FontMemory, 0);
676c698
<     VmaAllocation upload_buffer_allocation;
---
>     VkDeviceMemory upload_buffer_memory;
684,688c706,707
< 
<         VmaAllocationCreateInfo vmaalloc_info = {};
<         vmaalloc_info.usage = VMA_MEMORY_USAGE_CPU_ONLY;
<         err = vmaCreateBuffer(v->GPUAllocator, &buffer_info, &vmaalloc_info, &upload_buffer, &upload_buffer_allocation, nullptr);
< 
---
>         err = vkCreateBuffer(v->Device, &buffer_info, v->Allocator, &upload_buffer);
>         check_vk_result(err);
692c711,717
< 
---
>         VkMemoryAllocateInfo alloc_info = {};
>         alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
>         alloc_info.allocationSize = req.size;
>         alloc_info.memoryTypeIndex = ImGui_ImplVulkan_MemoryType(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, req.memoryTypeBits);
>         err = vkAllocateMemory(v->Device, &alloc_info, v->Allocator, &upload_buffer_memory);
>         check_vk_result(err);
>         err = vkBindBufferMemory(v->Device, upload_buffer, upload_buffer_memory, 0);
699c724
<         err = vmaMapMemory(v->GPUAllocator, upload_buffer_allocation, (void**)(&map));
---
>         err = vkMapMemory(v->Device, upload_buffer_memory, 0, upload_size, 0, (void**)(&map));
702c727,733
<         vmaUnmapMemory(v->GPUAllocator, upload_buffer_allocation);
---
>         VkMappedMemoryRange range[1] = {};
>         range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
>         range[0].memory = upload_buffer_memory;
>         range[0].size = upload_size;
>         err = vkFlushMappedMemoryRanges(v->Device, 1, range);
>         check_vk_result(err);
>         vkUnmapMemory(v->Device, upload_buffer_memory);
718c749
<         vkCmdPipelineBarrier(fontCommandBuffer, VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, copy_barrier);
---
>         vkCmdPipelineBarrier(bd->FontCommandBuffer, VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, copy_barrier);
726c757
<         vkCmdCopyBufferToImage(fontCommandBuffer, upload_buffer, bd->FontImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
---
>         vkCmdCopyBufferToImage(bd->FontCommandBuffer, upload_buffer, bd->FontImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
740c771
<         vkCmdPipelineBarrier(fontCommandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, use_barrier);
---
>         vkCmdPipelineBarrier(bd->FontCommandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, use_barrier);
750,751c781,782
<     end_info.pCommandBuffers = &fontCommandBuffer;
<     err = vkEndCommandBuffer(fontCommandBuffer);
---
>     end_info.pCommandBuffers = &bd->FontCommandBuffer;
>     err = vkEndCommandBuffer(bd->FontCommandBuffer);
759,761c790,792
<     vmaDestroyBuffer(v->GPUAllocator, upload_buffer, upload_buffer_allocation);
<     vkFreeCommandBuffers(v->Device, bd->FontCommandPool, 1, &fontCommandBuffer);
<     vkResetCommandPool(v->Device, bd->FontCommandPool, 0);
---
>     vkDestroyBuffer(v->Device, upload_buffer, v->Allocator);
>     vkFreeMemory(v->Device, upload_buffer_memory, v->Allocator);
> 
780c811,812
<     if (bd->FontImage || bd->FontAllocation) { vmaDestroyImage(v->GPUAllocator, bd->FontImage, bd->FontAllocation); bd->FontImage = VK_NULL_HANDLE; bd->FontAllocation = nullptr; }
---
>     if (bd->FontImage)  { vkDestroyImage(v->Device, bd->FontImage, v->Allocator); bd->FontImage = VK_NULL_HANDLE; }
>     if (bd->FontMemory) { vkFreeMemory(v->Device, bd->FontMemory, v->Allocator); bd->FontMemory = VK_NULL_HANDLE; }
783c815
< static void ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator, uint32_t* vert_data, size_t vert_size, uint32_t* frag_data, size_t frag_size)
---
> static void ImGui_ImplVulkan_CreateShaderModules(VkDevice device, const VkAllocationCallbacks* allocator)
791,792c823,824
<         vert_info.codeSize = vert_size * sizeof(uint32_t);
<         vert_info.pCode = vert_data;
---
>         vert_info.codeSize = sizeof(__glsl_shader_vert_spv);
>         vert_info.pCode = (uint32_t*)__glsl_shader_vert_spv;
800,801c832,833
<         frag_info.codeSize = frag_size * sizeof(uint32_t);
<         frag_info.pCode = frag_data;
---
>         frag_info.codeSize = sizeof(__glsl_shader_frag_spv);
>         frag_info.pCode = (uint32_t*)__glsl_shader_frag_spv;
810,812c842
< 
<     ImGui_ImplVulkan_InitInfo* v = &bd->VulkanInitInfo;
<     ImGui_ImplVulkan_CreateShaderModules(device, allocator, v->VertData, v->VertSize, v->FragData, v->FragSize);
---
>     ImGui_ImplVulkan_CreateShaderModules(device, allocator);
915d944
<     pipelineRenderingCreateInfo.depthAttachmentFormat = bd->VulkanInitInfo.DepthAttachmentFormat;
994a1024
>     if (bd->FontCommandBuffer)    { vkFreeCommandBuffers(v->Device, bd->FontCommandPool, 1, &bd->FontCommandBuffer); bd->FontCommandBuffer = VK_NULL_HANDLE; }
1258,1259c1288,1289
<             //err = vkCreateCommandPool(device, &info, allocator, &fd->CommandPool);
<             //check_vk_result(err);
---
>             err = vkCreateCommandPool(device, &info, allocator, &fd->CommandPool);
>             check_vk_result(err);
1267,1268c1297,1298
<             //err = vkAllocateCommandBuffers(device, &info, &fd->CommandBuffer);
<             //check_vk_result(err);
---
>             err = vkAllocateCommandBuffers(device, &info, &fd->CommandBuffer);
>             check_vk_result(err);
1504,1505c1534,1535
<     //vkFreeCommandBuffers(device, fd->CommandPool, 1, &fd->CommandBuffer);
<     //vkDestroyCommandPool(device, fd->CommandPool, allocator);
---
>     vkFreeCommandBuffers(device, fd->CommandPool, 1, &fd->CommandBuffer);
>     vkDestroyCommandPool(device, fd->CommandPool, allocator);
1523,1535c1553,1556
<     ImGui_ImplVulkan_Data* bd = ImGui_ImplVulkan_GetBackendData();
<     ImGui_ImplVulkan_InitInfo* v = &bd->VulkanInitInfo;
< 
<     if (buffers->VertexBuffer) {
<         vmaDestroyBuffer(v->GPUAllocator, buffers->VertexBuffer, buffers->VertexBufferAllocation);
<         buffers->VertexBuffer = VK_NULL_HANDLE;
<         buffers->VertexBufferAllocation = nullptr;
<     }
<     if (buffers->IndexBuffer) {
<         vmaDestroyBuffer(v->GPUAllocator, buffers->IndexBuffer, buffers->IndexBufferAllocation);
<         buffers->IndexBuffer = VK_NULL_HANDLE;
<         buffers->IndexBufferAllocation = nullptr;
<     }
---
>     if (buffers->VertexBuffer) { vkDestroyBuffer(device, buffers->VertexBuffer, allocator); buffers->VertexBuffer = VK_NULL_HANDLE; }
>     if (buffers->VertexBufferMemory) { vkFreeMemory(device, buffers->VertexBufferMemory, allocator); buffers->VertexBufferMemory = VK_NULL_HANDLE; }
>     if (buffers->IndexBuffer) { vkDestroyBuffer(device, buffers->IndexBuffer, allocator); buffers->IndexBuffer = VK_NULL_HANDLE; }
>     if (buffers->IndexBufferMemory) { vkFreeMemory(device, buffers->IndexBufferMemory, allocator); buffers->IndexBufferMemory = VK_NULL_HANDLE; }
diff -r imgui/backends/imgui_impl_vulkan.h imgui-master/backends/imgui_impl_vulkan.h
50d49
< #include <vma/vk_mem_alloc.h>
71d69
<     VkFormat                        DepthAttachmentFormat;  // Required for dynamic rendering
76,80d73
<     VmaAllocator                    GPUAllocator;
<     size_t FragSize;
<     uint32_t* FragData;
<     size_t VertSize;
<     uint32_t* VertData;
